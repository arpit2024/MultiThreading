/*
ğŸ” Intrinsic Lock vs Explicit Lock (Important for threading)

1ï¸âƒ£ Intrinsic Lock (a.k.a Monitor Lock)
---------------------------------------
â€¢ This is the default lock mechanism used by Java when we apply 'synchronized'.
â€¢ Every Java object has an intrinsic lock internally.
â€¢ When a thread enters a synchronized method/block, it acquires that object's lock.
â€¢ Only one thread can hold the lock at a time â†’ others are forced to wait.

Limitations of intrinsic lock:
  âœ˜ Cannot interrupt a waiting thread
  âœ˜ Cannot attempt timed locking (no try for few seconds)
  âœ˜ No fairness guarantee
  âœ˜ Cannot check whether lock is free before entering

Usage example:
    synchronized void withdraw() { ... }
    synchronized (this) { ... }


2ï¸âƒ£ Explicit Lock (ReentrantLock from java.util.concurrent.locks)
------------------------------------------------------------------
â€¢ A lock object we manually create and manage.
â€¢ Provides much more control than 'synchronized'.

Advantages over intrinsic lock:
  âœ” tryLock() â†’ take lock only if it is available
  âœ” tryLock(timeout) â†’ wait only for given time
  âœ” lockInterruptibly() â†’ thread can be interrupted while waiting for lock
  âœ” Fairness policy â†’ first waiting thread gets lock first
  âœ” Condition objects â†’ advanced wait/notify mechanism

Usage example:
    ReentrantLock lock = new ReentrantLock();
    lock.lock();
    try { ... }
    finally { lock.unlock(); }   // must be released manually

Summary:
--------
Intrinsic Lock (synchronized) â†’ simple, automatic, but limited.
Explicit Lock (ReentrantLock) â†’ more powerful and flexible but needs manual handling.
*/
