/*
===========================================================
ğŸ¦  Synchronization in Java (Context of this Code)
===========================================================
In this example, multiple threads try to withdraw money from
a shared BankAccount object. Since balance is shared data,
we must protect it from race conditions (2 threads modifying
balance at the same time). That is why withdraw() is marked
as 'synchronized' â€” allowing only ONE thread to execute the
method at a time.

Thread flow:
------------
t1 enters withdraw() â†’ prints, sleeps, deducts balance â†’ exits
t2 waits until t1 releases the lock â†’ then withdraws

This ensures data safety and prevents inconsistent balance.
===========================================================


âš  Disadvantages of 'synchronized' keyword (Why t2 waits)
===========================================================
ğŸ”¸ 1. Blocking behavior
    If one thread (t1) is inside withdraw(), other threads
    (t2, t3â€¦) MUST wait â€” even if they want to execute another
    block of code inside the same object.

ğŸ”¸ 2. No lock interruption
    A thread waiting for an intrinsic lock CANNOT be interrupted
    using interrupt(). It must wait until the lock is released.

ğŸ”¸ 3. No lock timeout
    We cannot say â€œWait only 2 seconds for the lock â€” if not acquired,
    do something elseâ€. It always waits indefinitely.

ğŸ”¸ 4. No lock fairness
    The JVM does NOT guarantee that the thread that waits longest
    gets the lock first. A thread may be starved.

ğŸ”¸ 5. Cannot check lock availability
    We cannot ask:
        "Is lock free? If yes â†’ take it; if no â†’ skip."
    The thread immediately blocks until lock is available.

These limitations become critical in high-performance,
real-time or highly concurrent systems.
===========================================================


ğŸš€ Why do we go for Locks (ReentrantLock)
===========================================================
The java.util.concurrent.locks package provides better control:

âœ” tryLock() â†’ lock only if available
âœ” lockInterruptibly() â†’ waiting thread can be interrupted
âœ” lock fairness policy â†’ prevents starvation
âœ” Explicit unlock() â†’ can release in finally block
âœ” Offers Condition objects â†’ wait / signal with more flexibility

In summary:
-----------
'synchronized' is simple and safe â†’ suitable for basic mutual
exclusion. But for advanced concurrency where timeouts, fairness,
interruption, or higher performance are required, ReentrantLock
and other modern lock implementations are preferred.
===========================================================
*/
